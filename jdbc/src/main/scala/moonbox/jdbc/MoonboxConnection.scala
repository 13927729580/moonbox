/*-
 * <<
 * Moonbox
 * ==
 * Copyright (C) 2016 - 2018 EDP
 * ==
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * >>
 */

package moonbox.jdbc

import java.sql.{Blob, CallableStatement, Clob, Connection, DatabaseMetaData, NClob, PreparedStatement, SQLException, SQLWarning, SQLXML, Savepoint, Statement, Struct}
import java.util.Properties
import java.util.concurrent.Executor
import java.{sql, util}

import moonbox.client.JdbcClient
import moonbox.common.message.{JdbcLoginInbound, JdbcLoginOutbound}
import org.apache.commons.codec.digest.DigestUtils

class MoonboxConnection(url: String, props: Properties) extends java.sql.Connection {

  import moonbox.util.MoonboxJDBCUtils._

  private var jdbcSession: JdbcSession = _
  var statement: MoonboxStatement = _
  var closed: Boolean = _
  var database: String = _
  var networkTimeout: Int = 1000 * 60 * 3
  var DEFAULT_USER_CHECK_TIMEOUT = 1000 * 60 * 5

  def userCheck(): Boolean = {
    var flag = false
    val newProps = parseURL(url, props)
    val username = newProps.getProperty(USER_KEY)
    val pwd = newProps.getProperty(PASSWORD_KEY)
    database = newProps.getProperty(DB_NAME)
    val table = {
      val tb = newProps.getProperty("table")
      if (tb != null) tb
      else newProps.getProperty("collection")
    }
    // TODO: Support cluster?
    // use the first host and port pair to get a JdbcClient
    val (host, port) = parseHostsAndPorts(newProps.getProperty(HOSTS_AND_PORTS)).map { case (h, p) => (h, p.toInt) }.head
    val client = new JdbcClient(host, port)
    client.connect()
    if (client.isConnected()) {
      val messageId = client.getMessageId()
      val resp = client.sendAndReceive(JdbcLoginInbound(messageId, username, pwd, database), DEFAULT_USER_CHECK_TIMEOUT)
      resp match {
        case msg: JdbcLoginOutbound =>
          msg.err match {
            case Some(err) =>
              client.close()
              throw new SQLException(s"Get connection error when checking username and password: $err)")
            case None =>
              flag = true
              initSession(client, database, table, username, pwd, newProps)
          }
        case e: Exception =>
          client.close()
          throw new SQLException(s"Get MoonboxConnection error: $e")
        case null =>
          client.close()
          throw new SQLException(s"Server's response message for ${username}'s login: null")
        case _ =>
          client.close()
          throw new SQLException("Unknown response")
      }
    }
    flag
  }

  private def initSession(jdbcClient: JdbcClient, database: String, table: String, username: String, pwd: String, props: Properties): Unit = {
    if (pwd != null && pwd.length > 0)
      jdbcSession = JdbcSession(jdbcClient, database, table, username, DigestUtils.md5Hex(pwd), props)
    else
      jdbcSession = JdbcSession(jdbcClient, database, table, username, pwd, props)
    closed = false
  }

  def getSession(): JdbcSession = jdbcSession

  //  override def commit(): Unit = throw new SQLException("Unsupported")

  override def commit(): Unit = throw new SQLException("Unsupported")

  override def getHoldability: Int = throw new SQLException("Unsupported")

  override def setCatalog(catalog: String): Unit = {
    // TODO: re-init the jdbcSession
    database = catalog
  }

  override def setHoldability(holdability: Int): Unit = {
    //throw new SQLException("Unsupported")
  }

  override def prepareStatement(sql: String): PreparedStatement = throw new SQLException("Unsupported")

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement = throw new SQLException("Unsupported")

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement = throw new SQLException("Unsupported")

  override def prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement = throw new SQLException("Unsupported")

  override def prepareStatement(sql: String, columnIndexes: Array[Int]): PreparedStatement = throw new SQLException("Unsupported")

  override def prepareStatement(sql: String, columnNames: Array[String]): PreparedStatement = throw new SQLException("Unsupported")

  override def createClob(): Clob = throw new SQLException("Unsupported")

  override def setSchema(schema: String): Unit = {
    //throw new SQLException("Unsupported")
  }

  override def setClientInfo(name: String, value: String): Unit = {
    //throw new SQLException("Unsupported")
  }

  override def setClientInfo(properties: Properties): Unit = {
    //throw new SQLException("Unsupported")
  }

  override def createSQLXML(): SQLXML = throw new SQLException("Unsupported")

  override def getCatalog: String = database

  override def createBlob(): Blob = throw new SQLException("Unsupported")

  def checkClosed(): Unit = {
    if (isClosed()){
      throw new SQLException("Connection is already closed.")
    }
  }

  override def createStatement(): Statement = {
    checkClosed()
    statement = new MoonboxStatement(this)
    statement
  }

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement = createStatement() // TODO: createStatement(resultSetType: Int, resultSetConcurrency: Int)

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement = createStatement() // TODO: createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int)

  override def abort(executor: Executor): Unit = this.close() // TODO: abort

  override def setAutoCommit(autoCommit: Boolean): Unit = {
    //throw new SQLException("Unsupported")
  } // TODO: setAutoCommit

  override def getMetaData: DatabaseMetaData = throw new SQLException("Unsupported") // TODO: getMetaData: DatabaseMetaData

  override def setReadOnly(readOnly: Boolean): Unit = {
    //throw new SQLException("Unsupported")
  } // TODO: setReadOnly

  override def prepareCall(sql: String): CallableStatement = throw new SQLException("Unsupported")

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): CallableStatement = throw new SQLException("Unsupported")

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): CallableStatement = throw new SQLException("Unsupported")

  override def setTransactionIsolation(level: Int): Unit = {
    // throw new SQLException("Unsupported")
  }


  //  private def closeSession(jdbcSession: JdbcSession): Unit = {
  //    val messageId = jdbcSession.jdbcClient.getMessageId()
  //    val resp = jdbcSession.jdbcClient.sendAndReceive(JdbcLogoutInbound(messageId))
  //    resp match {
  //      case r: JdbcLogoutOutbound =>
  //        if (r.err.isDefined) {
  //          throw new SQLException(s"Jdbc connection close error: ${r.err.get}")
  //        } else {
  //          jdbcSession.jdbcClient.close()
  //          jdbcSession.closed = true
  //        }
  //      case other => throw new SQLException(s"Jdbc connection close error: $other")
  //    }
  //  }

  override def getWarnings: SQLWarning = {
    throw new SQLException("Unsupported")
  }

  override def releaseSavepoint(savepoint: Savepoint): Unit = throw new SQLException("Unsupported")

  override def nativeSQL(sql: String): String = throw new SQLException("Unsupported")

  override def isReadOnly: Boolean = throw new SQLException("Unsupported")

  override def createArrayOf(typeName: String, elements: Array[AnyRef]): sql.Array = throw new SQLException("Unsupported")

  override def setSavepoint(): Savepoint = {
    throw new SQLException("Unsupported")
  }

  override def setSavepoint(name: String): Savepoint = {
    throw new SQLException("Unsupported")
  }

  override def close(): Unit = {
    if (statement != null && !statement.isClosed) {
      statement.close()
    }
    statement = null
    //    closeSession(jdbcSession)
    if (jdbcSession != null || !jdbcSession.isClosed()) {
      jdbcSession.close()
    }
    jdbcSession = null
    closed = true
  }

  override def createNClob(): NClob = throw new SQLException("Unsupported")

  override def rollback(): Unit = throw new SQLException("Unsupported")

  override def rollback(savepoint: Savepoint): Unit = throw new SQLException("Unsupported")

  override def setNetworkTimeout(executor: Executor, milliseconds: Int): Unit = {
    networkTimeout = milliseconds
    //throw new SQLException("unsupported")
  }

  override def setTypeMap(map: util.Map[String, Class[_]]): Unit = {
    //throw new SQLException("Unsupported")
  }

  override def isValid(timeout: Int): Boolean = {
    if (jdbcSession == null || isClosed()) false else true
  }

  override def getAutoCommit: Boolean = {
//    throw new SQLException("Unsupported")
    false
  }

  override def clearWarnings(): Unit = {
    //throw new SQLException("Unsupported")
  }

  override def getSchema: String = throw new SQLException("Unsupported")

  override def getNetworkTimeout: Int = {
    //    throw new SQLException("unsupported")
    networkTimeout
  }

  override def isClosed(): Boolean = {
    synchronized {
      if (jdbcSession == null || jdbcSession.isClosed()) {
        closed = true
      }
      closed
    }
  }

  override def getTransactionIsolation: Int = {
    Connection.TRANSACTION_NONE
    //throw new SQLException("Unsupported")
  }

  override def createStruct(typeName: String, attributes: Array[AnyRef]): Struct = throw new SQLException("Unsupported")

  override def getClientInfo(name: String): String = throw new SQLException("Unsupported")

  override def getClientInfo: Properties = throw new SQLException("Unsupported")

  override def getTypeMap: util.Map[String, Class[_]] = throw new SQLException("Unsupported")

  override def unwrap[T](iface: Class[T]): T = {
    if (isWrapperFor(iface))
      this.asInstanceOf[T]
    else
      throw new SQLException("unwrap exception")
  }

  override def isWrapperFor(iface: Class[_]): Boolean = iface != null && iface.isAssignableFrom(getClass)
}
